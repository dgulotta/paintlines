/***************************************************************************
 *   Copyright (C) 2005-2008, 2013, 2016 by Daniel Gulotta                 *
 *   dgulotta@alum.mit.edu                                                 *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the Free Software           *
 *   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA         *
 *   02110-1301  USA                                                       *
 ***************************************************************************/

#ifndef _HYPERBOLIC_GROUP_H
#define _HYPERBOLIC_GROUP_H

#include <functional>
#include <unordered_map>
#include <vector>
#include "hyperbolic.h"
#include "hyperbolic_polygons.h"

enum class flip_type { ALL, ALTERNATING, RANDOM };

/*
 * Given a fundamental domain D, the group is generated by transformations that
 * send D to its neighbors.  This struct contains a generator and the edge that D
 * shares with the corresponding neighbor.
 */
struct generator {
	hyperbolic_transformation trans;
	hyperbolic_coord edge;
	bool is_flip;
	/*
	 * edge divides the plane into two regions.  Returns true if the given
	 * point is contained in the same region as the fundamental domain.
	 * A point is inside the fundamental domain iff inside returns true for
	 * each generator.
	 */
	generator(const hyperbolic_transformation &t, const hyperbolic_coord &e) : trans(t), edge(e), is_flip(t.is_flip()) {}
	bool inside(const hyperbolic_coord &hc) const { return edge*hc+1.e-15>=0; }
};

hyperbolic_coord fundamental_domain_point(const std::vector<generator> &gens, hyperbolic_coord c);

class fundamental_domain_family;

struct fundamental_domain
{
	std::vector<generator> generators;
	hyperbolic_polygon polygon;
	const fundamental_domain_family *family;
};

class fundamental_domain_family
{
public:
	struct side {
		int opposite;
		bool flip;
		bool operator == (const side &s) const { return opposite==s.opposite&&flip==s.flip; }
	};
	fundamental_domain_family() {}
	fundamental_domain_family(const std::vector<side> &e);
	fundamental_domain_family(const std::initializer_list<side> &e) : fundamental_domain_family(std::vector<side>(e)) {}
	int rotation_count() const;
	std::vector<int> rotation_point_counts() const;
	std::vector<int> mirror_counts() const;
	std::vector<std::vector<int>> mirror_point_counts() const;
	int rot180s() const;
	bool orientable() const;
	int loops() const;
	const std::vector<side> & get_edges() const { return edges; }
	fundamental_domain domain(const std::vector<int> &rotations) const;
private:
	enum class edge_type { ROT180, MIRROR, ROT_TRANS, GLIDE };
	void other_edge(int &e, const int &v) const;
	void other_vertex(const int &e, int &v) const;
	void other_corner(int &e, int &v) const;
	std::vector<side> edges;
	std::vector<std::vector<std::vector<int>>> mirrors;
	std::vector<std::vector<int>> rotations;
	edge_type type_of_edge(int i) const;
	void verify_hyperbolic(const std::vector<int> &rotations) const;
};

class hyperbolic_symmetry_group {
	public:
		hyperbolic_symmetry_group(const std::vector<generator> &s, flip_type f=flip_type::ALL);
		template <typename F>
			std::function<void(const hyperbolic_coord &)> symmetrize(const F &f) const;
		hyperbolic_coord random_symmetry(const hyperbolic_coord &c) const;
	private:
		std::vector<generator> generators;
		std::vector<hyperbolic_transformation> transformations;
		std::vector<hyperbolic_transformation> flips;
		std::tuple<hyperbolic_coord,bool> fundamental_domain(const hyperbolic_coord &hc) const;
		std::tuple<hyperbolic_coord,bool> fundamental_domain_alternating(const hyperbolic_coord &hc) const;
		std::tuple<hyperbolic_coord,bool> fundamental_domain_random(const hyperbolic_coord &hc) const;
		mutable std::unordered_map<long,bool> random_flips;
		decltype(&hyperbolic_symmetry_group::fundamental_domain) fdfunc;
};

template<typename F>
std::function<void(const hyperbolic_coord &)> hyperbolic_symmetry_group::symmetrize(const F &f) const {
	return [this,f](const hyperbolic_coord &hc) {
		auto s = (this->*fdfunc)(hc);
		hyperbolic_coord c=std::get<0>(s);
		if(std::get<1>(s))
			for(auto &t : flips)
				f(t(c));
		else
			for(auto &t : transformations)
				f(t(c));
	};
}

#endif
